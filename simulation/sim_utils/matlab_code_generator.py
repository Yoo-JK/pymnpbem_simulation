"""
MATLAB Code Generator

Generates complete MATLAB simulation scripts with field calculation support.
Supports nonlocal quantum corrections for sub-nanometer gaps.
Supports parallel computing with parfor (single node, multiple cores).
"""
import os
import numpy as np
from .nonlocal_generator import NonlocalGenerator


class MatlabCodeGenerator:
    """Generates complete MATLAB simulation code."""
    
    def __init__(self, config, verbose=False):
        self.config = config
        self.verbose = verbose

        # Auto-disable H2 compression when substrate is used (known MNPBEM MEX bug)
        use_substrate = config.get('use_substrate', False)
        use_h2 = config.get('use_h2_compression', False)

        if use_substrate and use_h2:
            print("[!] WARNING: H2 compression is incompatible with substrate mode")
            print("    (MNPBEM MEX file 'hmatgreentab1' causes segmentation fault)")
            print("    -> Automatically disabling H2 compression")
            self.config['use_h2_compression'] = False

        self.nonlocal_gen = NonlocalGenerator(config, verbose)
    
    def generate_complete_script(self, geometry_code, material_code):
        """Generate complete MATLAB simulation script."""

        self._extract_closed_args(material_code)
        
        # Header
        header = self._generate_header()
        
        # Options
        options = self._generate_options()
        
        # Geometry
        geometry = geometry_code
        
        # Materials
        materials = material_code
        
        # Comparticle creation
        comparticle = self._generate_comparticle()
        
        # Validation (if nonlocal)
        validation = self._validate_nonlocal_setup()

        # Green function tabulation
        greentab = self._generate_substrate_greentab()
        
        # BEM solver
        bem_solver = self._generate_bem_solver()
        
        # Excitation
        excitation = self._generate_excitation()

        # Wavelength loop (with chunking support!)
        chunk_size = self.config.get('wavelength_chunk_size', None)
        if chunk_size:
            # Use memory-efficient chunking
            wavelength_loop = self._generate_wavelength_loop_with_chunking()
            if self.verbose:
                print(f"✓ Using wavelength chunking: {chunk_size} wavelengths per chunk")
        else:
            # Use standard loop
            wavelength_loop = self._generate_wavelength_loop()
            if self.verbose:
                print("✓ Using standard wavelength loop (no chunking)")
        
        # Save results
        save_results = self._generate_save_results()
        
        # Footer (now with parallel cleanup!)
        footer = self._generate_footer()
        
        # Combine all parts
        complete_code = f"""{header}

{options}

{geometry}

{materials}

{comparticle}

{validation}

{greentab}

{bem_solver}

{excitation}

{wavelength_loop}

{save_results}

{footer}
"""
        return complete_code
    
    def _generate_header(self):
        """Generate script header."""
        code = """% MNPBEM Simulation Script
% Auto-generated by MNPBEM Automation Pipeline
%
% DO NOT EDIT THIS FILE MANUALLY
% Modify the configuration file instead and regenerate

clear all;
close all;
clc;

fprintf('=== MNPBEM Simulation Started ===\\n');
fprintf('Structure: %s\\n', '{structure}');
fprintf('Simulation Type: %s\\n', '{sim_type}');
""".format(
            structure=self.config['structure'],
            sim_type=self.config['simulation_type']
        )
        return code
    
    def _generate_options(self):
        """Generate BEM options with proper settings."""
        sim_type = self.config['simulation_type']
        use_mirror = self.config.get('use_mirror_symmetry', False)
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate and sim_type != 'ret':
            raise ValueError(
                "Substrate simulations require 'ret' (retarded) simulation type. "
                f"Current simulation_type is '{sim_type}'. "
                "Please set: args['simulation_type'] = 'ret'"
            )
        
        refine = self.config.get('refine', 3 if use_nonlocal else 1)
        relcutoff = self.config.get('relcutoff', 2 if use_iterative else 3)
        
        code = f"""
%% BEM Options
fprintf('\\nSetting up BEM options...\\n');
"""
        
        # Base options
        if sim_type == 'stat':
            code += "op = bemoptions( 'sim', 'stat', 'interp', 'curv' );\n"
        else:
            code += "op = bemoptions( 'sim', 'ret', 'interp', 'curv' );\n"
        
        code += f"op.refine = {refine};\n"

        if use_substrate:
            code += """
fprintf('  [OK] Substrate mode enabled\\n');
fprintf('  [!] Green function tabulation will be required\\n');
"""
        
        # Mirror symmetry
        if use_mirror:
            if isinstance(use_mirror, str):
                sym = use_mirror
            else:
                sym = 'xy'
            code += f"op.sym = '{sym}';\n"
            code += f"fprintf('  [OK] Mirror symmetry: {sym}\\n');\n"
        
        # Nonlocal options (high precision integration)
        if use_nonlocal:
            nonlocal_opts = self.nonlocal_gen.generate_bem_options()
            code += nonlocal_opts
        
        # Iterative solver options
        if use_iterative:
            code += f"""
%% Iterative Solver Options
relcutoff = {relcutoff};
fprintf('  [OK] Iterative solver: relcutoff=%d\\n', relcutoff);
"""
        
        code += "\nfprintf('[OK] BEM options configured\\n');\n"
        
        return code
    
    def _generate_parallel_setup(self):
        """Generate parallel pool setup code with computational threads control."""
        num_workers = self.config.get('num_workers', 'auto')
        max_comp_threads = self.config.get('max_comp_threads', 'auto')
        
        code = """
%% Parallel Computing Setup
fprintf('\\n=== Setting up Parallel Computing ===\\n');

"""
        
        # Determine number of workers based on config
        if num_workers == 'env':
            code += """% Get number of workers from environment variable
if ~isempty(getenv('MNPBEM_NUM_WORKERS'))
    requested_workers = str2double(getenv('MNPBEM_NUM_WORKERS'));
    fprintf('Reading from environment: MNPBEM_NUM_WORKERS=%d\\n', requested_workers);
elseif ~isempty(getenv('SLURM_CPUS_PER_TASK'))
    requested_workers = str2double(getenv('SLURM_CPUS_PER_TASK'));
    fprintf('Detected Slurm environment: SLURM_CPUS_PER_TASK=%d\\n', requested_workers);
else
    requested_workers = feature('numcores');
    fprintf('Auto-detected available cores: %d\\n', requested_workers);
end
"""
        elif num_workers == 'auto':
            code += """% Auto-detect available cores
requested_workers = feature('numcores');
fprintf('Auto-detected available cores: %d\\n', requested_workers);
"""
        elif isinstance(num_workers, int):
            code += f"""% Using specified number of workers
requested_workers = {num_workers};
fprintf('Using specified workers: %d\\n', requested_workers);
"""
        else:
            code += """% Default to 1 worker (serial)
requested_workers = 1;
fprintf('Using default: 1 worker (serial execution)\\n');
"""
        
        # ✅ NEW: Computational threads configuration
        code += """
%% Computational Threads Configuration
% Control threads used by BLAS, FFT, and other low-level operations
total_cores = feature('numcores');
fprintf('\\nTotal system cores: %d\\n', total_cores);

"""
        
        if max_comp_threads == 'auto':
            code += """% Auto-calculate: divide cores by workers
if requested_workers > 1
    % Parallel mode: divide cores among workers
    comp_threads = max(1, floor(total_cores / requested_workers));
    fprintf('Auto-calculated computational threads: %d per worker\\n', comp_threads);
    fprintf('  (Total cores %d / %d workers = %d threads each)\\n', ...
            total_cores, requested_workers, comp_threads);
else
    % Serial mode: use all cores for single worker
    comp_threads = total_cores;
    fprintf('Serial mode: using all %d cores for computational threads\\n', comp_threads);
end
"""
        elif max_comp_threads == 'max':
            code += """% Use maximum: all cores for each worker (may cause over-subscription!)
comp_threads = total_cores;
fprintf('WARNING: Using all %d cores per worker\\n', comp_threads);
if requested_workers > 1
    fprintf('  This will cause over-subscription: %d workers × %d threads = %d threads!\\n', ...
            requested_workers, comp_threads, requested_workers * comp_threads);
end
"""
        elif isinstance(max_comp_threads, int):
            code += f"""% Using specified computational threads
comp_threads = {max_comp_threads};
fprintf('Using specified computational threads: %d per worker\\n', comp_threads);
"""
        else:
            code += """% Default: 1 thread per worker
comp_threads = 1;
fprintf('Using default: 1 computational thread per worker\\n');
"""
        
        code += """
% Set computational threads
fprintf('Setting maxNumCompThreads to %d...\\n', comp_threads);
maxNumCompThreads(comp_threads);
current_threads = maxNumCompThreads();
fprintf('  [OK] Current maxNumCompThreads: %d\\n', current_threads);

% Display parallelism summary
fprintf('\\n--- Parallelism Configuration ---\\n');
fprintf('  Workers (parfor):        %d\\n', requested_workers);
fprintf('  Threads per worker:      %d\\n', comp_threads);
fprintf('  Total parallel threads:  %d\\n', requested_workers * comp_threads);
fprintf('  System cores available:  %d\\n', total_cores);
if requested_workers * comp_threads > total_cores
    fprintf('  [!] WARNING: Over-subscription detected!\\n');
    fprintf('     %d parallel threads competing for %d cores\\n', ...
            requested_workers * comp_threads, total_cores);
else
    fprintf('  [OK] Good: No over-subscription\\n');
end
fprintf('----------------------------------\\n\\n');

"""
        
        code += """
% Create parallel pool
try
    % Check if pool already exists
    existing_pool = gcp('nocreate');
    
    if isempty(existing_pool)
        % No existing pool, create new one
        if requested_workers > 1
            fprintf('Creating parallel pool with %d workers...\\n', requested_workers);
            pool = parpool('local', requested_workers);
            fprintf('[OK] Parallel pool created successfully: %d workers\\n', pool.NumWorkers);

            % CRITICAL: Propagate maxNumCompThreads to ALL workers!
            % Without this, workers use default threads (usually 1)
            fprintf('Setting maxNumCompThreads(%d) on all workers...\\n', comp_threads);
            pctRunOnAll(sprintf('maxNumCompThreads(%d);', comp_threads));

            % Verify the setting was applied
            fprintf('Verifying worker thread settings...\\n');
            worker_threads = zeros(1, pool.NumWorkers);
            parfor i = 1:pool.NumWorkers
                worker_threads(i) = maxNumCompThreads();
            end
            fprintf('  Worker thread counts: [%s]\\n', num2str(worker_threads));
            if all(worker_threads == comp_threads)
                fprintf('[OK] All %d workers confirmed with %d threads each\\n', pool.NumWorkers, comp_threads);
            else
                fprintf('[WARNING] Thread mismatch! Expected %d, got: [%s]\\n', comp_threads, num2str(worker_threads));
            end

            parallel_enabled = true;
        else
            fprintf('Serial execution mode (1 worker)\\n');
            pool = [];
            parallel_enabled = false;
        end
    else
        % Pool exists, use it
        pool = existing_pool;
        fprintf('[OK] Using existing parallel pool: %d workers\\n', pool.NumWorkers);

        % Also set threads on existing pool workers
        fprintf('Setting maxNumCompThreads(%d) on existing workers...\\n', comp_threads);
        pctRunOnAll(sprintf('maxNumCompThreads(%d);', comp_threads));

        % Verify the setting was applied
        fprintf('Verifying worker thread settings...\\n');
        worker_threads = zeros(1, pool.NumWorkers);
        parfor i = 1:pool.NumWorkers
            worker_threads(i) = maxNumCompThreads();
        end
        fprintf('  Worker thread counts: [%s]\\n', num2str(worker_threads));
        if all(worker_threads == comp_threads)
            fprintf('[OK] All %d workers confirmed with %d threads each\\n', pool.NumWorkers, comp_threads);
        else
            fprintf('[WARNING] Thread mismatch! Expected %d, got: [%s]\\n', comp_threads, num2str(worker_threads));
        end

        parallel_enabled = true;
    end
    
catch ME
    fprintf('[!] Warning: Failed to create parallel pool\\n');
    fprintf('Error: %s\\n', ME.message);
    fprintf('Continuing with serial execution...\\n');
    pool = [];
    parallel_enabled = false;
end

fprintf('=== Parallel Setup Complete ===\\n\\n');
"""
        return code
    
    def _generate_parallel_cleanup(self):
        """
        Generate safe parallel pool cleanup code.
        
        ✅ IMPROVEMENTS:
        1. Longer timeout for worker termination (15 seconds)
        2. Force kill if timeout
        3. Better verification
        """
        code = """
%% Parallel Computing Cleanup (IMPROVED!)
if exist('parallel_enabled', 'var') && parallel_enabled && ~isempty(gcp('nocreate'))
    fprintf('\\nCleaning up parallel pool...\\n');
    
    try
        pool = gcp('nocreate');
        if ~isempty(pool)
            % Get pool info
            n_workers = pool.NumWorkers;
            fprintf('  Shutting down %d workers...\\n', n_workers);
            
            % Delete the pool
            delete(pool);
            
            % IMPROVED: Wait with timeout for complete termination
            fprintf('  Waiting for workers to terminate...\\n');
            timeout = 15;  % 15 seconds timeout (increased from 2!)
            start_time = tic;
            
            while ~isempty(gcp('nocreate')) && toc(start_time) < timeout
                pause(0.5);
                % Print status every 3 seconds
                if mod(toc(start_time), 3) < 0.5
                    fprintf('    Still waiting... (%.1f seconds elapsed)\\n', toc(start_time));
                end
            end
            
            % Verify pool is completely gone
            remaining_pool = gcp('nocreate');
            if isempty(remaining_pool)
                fprintf('  [OK] Parallel pool closed successfully\\n');
            else
                fprintf('  WARNING: Pool cleanup timeout after %.1f seconds\\n', timeout);
                fprintf('     Some workers may still be running\\n');
                fprintf('     MATLAB will force-terminate on exit\\n');
                % Try force delete one more time
                try
                    delete(gcp('nocreate'));
                catch
                    % Ignore errors - will be cleaned up on exit
                end
            end
        end
    catch ME
        fprintf('  Warning during pool cleanup: %s\\n', ME.message);
        fprintf('     Continuing with exit anyway...\\n');
    end
end
"""
        return code
    
    def _generate_comparticle(self):
        """Generate comparticle object creation with visualization."""
        
        # Get closed indices from material manager
        closed_args = self._closed_args
        
        # Check if substrate is used
        use_substrate = self.config.get('use_substrate', False)

        if use_substrate:
            substrate = self.config.get('substrate', {})
            substrate_position = substrate.get('position', 0)
        
        code = """
%% Create Comparticle Object
fprintf('\\nCreating comparticle object...\\n');
p = comparticle(epstab, particles, inout, """ + closed_args + """, op);
fprintf('Comparticle created with %d boundary elements\\n', p.n);

%% Visualize and Save Structure
fprintf('\\nGenerating structure visualizations...\\n');

try
    n_particles = length(particles);
    
    % Define colors
    core_color = [1.0, 0.7, 0.3];  % Gold/orange for core
    shell_color_1 = [0.7, 0.85, 1.0];  % Light blue
    shell_color_2 = [0.5, 0.7, 0.95];  % Medium blue
    shell_color_3 = [0.3, 0.5, 0.9];   % Darker blue
    substrate_color = [0.85, 0.85, 0.85];  % Light gray
    
"""
        
        # Add substrate parameters
        if use_substrate:
            code += f"""    % Substrate parameters
    has_substrate = true;
    z_substrate = {substrate_position};
"""
        else:
            code += """    % No substrate
    has_substrate = false;
"""
        
        code += """    
    % Get particle bounds for plotting
    x_lim = [min(p.pos(:,1)), max(p.pos(:,1))];
    y_lim = [min(p.pos(:,2)), max(p.pos(:,2))];
    z_lim = [min(p.pos(:,3)), max(p.pos(:,3))];
    
    % Expand limits for substrate visualization
    x_expand = (x_lim(2) - x_lim(1)) * 0.3;
    y_expand = (y_lim(2) - y_lim(1)) * 0.3;
    x_range = [x_lim(1) - x_expand, x_lim(2) + x_expand];
    y_range = [y_lim(1) - y_expand, y_lim(2) + y_expand];
    
    % ========== 3D View ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    % Check if single or multi-particle structure
    if n_particles == 1
        % Single particle: simple plot
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        % Multi-particle (core-shell): plot with progressive transparency
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                % Core: opaque, gold color
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                % Shells: progressively more transparent
                shell_idx = i - 1;
                
                % Select transparency and color
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    % General case
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
        
        % Add legend for multi-layer structures
        legend_entries = cell(n_particles, 1);
        legend_entries{1} = 'Core';
        for i = 2:n_particles
            legend_entries{i} = sprintf('Shell %d', i-1);
        end
        legend(legend_entries, 'Location', 'northeast', 'FontSize', 10);
    end
    
    % Draw substrate interface (3D view)
    if has_substrate
        % Create substrate plane
        [X_sub, Y_sub] = meshgrid(x_range, y_range);
        Z_sub = ones(size(X_sub)) * z_substrate;
        surf(X_sub, Y_sub, Z_sub, 'FaceColor', substrate_color, ...
             'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Draw interface outline
        plot3([x_range(1), x_range(2), x_range(2), x_range(1), x_range(1)], ...
              [y_range(1), y_range(1), y_range(2), y_range(2), y_range(1)], ...
              [z_substrate, z_substrate, z_substrate, z_substrate, z_substrate], ...
              'k-', 'LineWidth', 2);
        
        % Add label
        text(x_range(2)*0.8, y_range(2)*0.8, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('3D View', 'FontSize', 14, 'FontWeight', 'bold');
    view(45, 30);
    grid on;
    box on;
    lighting gouraud;
    camlight('headlight');
    
    % Coordinate system indicator
    ax_small = axes('Position', [0.85, 0.75, 0.12, 0.2]);
    hold on;
    arrow_len = 1;
    quiver3(0, 0, 0, arrow_len, 0, 0, 'Color', 'r', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, arrow_len, 0, 'Color', 'g', 'LineWidth', 3, 'MaxHeadSize', 1);
    quiver3(0, 0, 0, 0, 0, arrow_len, 'Color', 'b', 'LineWidth', 3, 'MaxHeadSize', 1);
    text(arrow_len*1.3, 0, 0, 'x', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'r');
    text(0, arrow_len*1.3, 0, 'y', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'g');
    text(0, 0, arrow_len*1.3, 'z', 'FontSize', 14, 'FontWeight', 'bold', 'Color', 'b');
    axis equal;
    axis off;
    view(45, 30);
    xlim([-0.3, 1.5]);
    ylim([-0.3, 1.5]);
    zlim([-0.3, 1.5]);
    
    print('structure_3D.png', '-dpng', '-r300');
    fprintf('  [OK] 3D view saved\\n');
    close(fig);
    
    % ========== XY View (Top View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Substrate outline in XY view
    if has_substrate
        rectangle('Position', [x_range(1), y_range(1), ...
                              x_range(2)-x_range(1), y_range(2)-y_range(1)], ...
                 'EdgeColor', 'k', 'LineWidth', 2, 'LineStyle', '--');
        text(x_range(2)*0.85, y_range(2)*0.85, ...
             sprintf('Substrate z=%.1f', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k');
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('XY View (Top View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 90);
    grid on;
    box on;
    
    print('structure_XY.png', '-dpng', '-r300');
    fprintf('  [OK] XY view saved\\n');
    close(fig);
    
    % ========== YZ View (Side View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (YZ view - FIXED!)
    if has_substrate
        % Substrate line: x=0 plane, along y-axis, at z=z_substrate
        plot3([0, 0], ...
              [y_range(1), y_range(2)], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        y_fill = [y_range(1), y_range(2), y_range(2), y_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(y_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at y=y_mid
            y_mid = mean(y_range);
            plot3([0, 0], [y_mid, y_mid], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(0, y_mid, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(0, y_range(2)*0.85, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    ylabel('y (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('YZ View (Side View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(90, 0);
    grid on;
    box on;
    
    print('structure_YZ.png', '-dpng', '-r300');
    fprintf('  [OK] YZ view saved\\n');
    close(fig);
    
    % ========== ZX View (Front View) ==========
    fig = figure('Visible', 'off', 'Position', [100, 100, 1000, 800]);
    subplot('Position', [0.1, 0.1, 0.75, 0.85]);
    hold on;
    
    if n_particles == 1
        plot2(p, [0.8, 0.9, 1.0], 'FaceAlpha', 0.9);
    else
        for i = 1:n_particles
            alpha = 1.0;
            color = core_color;

            if i == 1
                plot2(particles{i}, core_color, 'FaceAlpha', 1.0);
            else
                shell_idx = i - 1;
                if n_particles == 2
                    alpha = 0.5;
                    color = shell_color_1;
                elseif n_particles == 3
                    if shell_idx == 1
                        alpha = 0.6;
                        color = shell_color_1;
                    else
                        alpha = 0.3;
                        color = shell_color_2;
                    end
                elseif n_particles == 4
                    if shell_idx == 1
                        alpha = 0.7;
                        color = shell_color_1;
                    elseif shell_idx == 2
                        alpha = 0.5;
                        color = shell_color_2;
                    else
                        alpha = 0.3;
                        color = shell_color_3;
                    end
                else
                    alpha = max(0.2, 0.8 - 0.2 * shell_idx);
                    if shell_idx == 1
                        color = shell_color_1;
                    elseif shell_idx == 2
                        color = shell_color_2;
                    else
                        color = shell_color_3;
                    end
                end
                plot2(particles{i}, color, 'FaceAlpha', alpha);
            end
        end
    end
    
    % Draw substrate interface line (ZX view - FIXED!)
    if has_substrate
        % Substrate line: y=0 plane, along x-axis, at z=z_substrate
        plot3([x_range(1), x_range(2)], ...
              [0, 0], ...
              [z_substrate, z_substrate], ...
              'k-', 'LineWidth', 3);
        
        % Fill substrate region below interface
        x_fill = [x_range(1), x_range(2), x_range(2), x_range(1)];
        z_fill = [z_substrate, z_substrate, z_lim(1)-20, z_lim(1)-20];
        fill(x_fill, z_fill, substrate_color, 'FaceAlpha', 0.3, 'EdgeColor', 'none');
        
        % Add gap annotation
        particle_bottom = min(p.pos(:,3));
        gap_distance = particle_bottom - z_substrate;
        if gap_distance > 0.1
            % Draw gap indicator: vertical line at x=x_mid
            x_mid = mean(x_range);
            plot3([x_mid, x_mid], [0, 0], [particle_bottom, z_substrate], ...
                  'r-', 'LineWidth', 2);
            text(x_mid, 0, (particle_bottom + z_substrate)/2, ...
                 sprintf('  Gap\\n  %.1f nm', gap_distance), ...
                 'FontSize', 10, 'FontWeight', 'bold', 'Color', 'r', ...
                 'BackgroundColor', 'w', 'EdgeColor', 'r');
        end
        
        % Label substrate
        text(x_range(2)*0.85, 0, z_substrate, ...
             sprintf('  Substrate\\n  z=%.1f nm', z_substrate), ...
             'FontSize', 10, 'FontWeight', 'bold', ...
             'BackgroundColor', 'w', 'EdgeColor', 'k', 'Margin', 3);
    end
    
    axis equal;
    xlabel('x (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    zlabel('z (nm)', 'FontSize', 12, 'FontWeight', 'bold');
    title('ZX View (Front View)', 'FontSize', 14, 'FontWeight', 'bold');
    view(0, 0);
    grid on;
    box on;
    
    print('structure_ZX.png', '-dpng', '-r300');
    fprintf('  [OK] ZX view saved\\n');
    close(fig);

    fprintf('  [OK] All structure visualizations completed!\\n');
    
catch ME
    fprintf('  Warning: Could not save structure plots: %s\\n', ME.message);
end
"""

        return code
    
    def _validate_nonlocal_setup(self):
        """Validate that nonlocal setup is correct."""
        if not self.nonlocal_gen.is_needed():
            return ""
        
        code = """
%% Validate Nonlocal Setup
fprintf('\\n=== Validating Nonlocal Setup ===\\n');

% Check number of particles
n_particles = length(particles);
fprintf('  Number of particle boundaries: %d\\n', n_particles);

% Check epstab
n_materials = length(epstab);
fprintf('  Number of materials in epstab: %d\\n', n_materials);

% Check inout matrix
[n_boundaries, ~] = size(inout);
fprintf('  Number of boundaries in inout: %d\\n', n_boundaries);

% Validation
if n_particles ~= n_boundaries
    error('Mismatch: %d particles but %d boundaries in inout!', n_particles, n_boundaries);
end

fprintf('[OK] Nonlocal setup validated\\n');
"""
        return code

    def _generate_substrate_greentab(self):
        """Generate Green function tabulation with field point coverage."""
        use_substrate = self.config.get('use_substrate', False)
        sim_type = self.config['simulation_type']
        
        if not (use_substrate and sim_type == 'ret'):
            return ""
        
        nz = self.config.get('greentab_nz', 30)
        scale = self.config.get('greentab_scale', 1.5)
        
        wavelength_range = self.config['wavelength_range']
        wl_min = wavelength_range[0]
        wl_max = wavelength_range[1]
        wl_num = wavelength_range[2]
        
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Green Function Tabulation (Required for Substrate)
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('        Setting up Green Function Table for Substrate          \\n');
fprintf('================================================================\\n');

% CRITICAL: Define actual simulation wavelengths FIRST
enei = linspace({wl_min}, {wl_max}, {wl_num});
fprintf('Simulation wavelengths: %.1f to %.1f nm (%d points)\\n', ...
        min(enei), max(enei), length(enei));
"""

        # ✅ FIX: Field points를 tabulation에 포함!
        if calculate_fields:
            field_region = self.config.get('field_region', {})
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            code += """
% Set up field points for Green function tabulation
fprintf('\\nPreparing field mesh for tabulation...\\n');
"""
        
            if y_range[2] == 1:  # xz-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += """
% Store grid shape for later use
grid_shape = size(x_grid);
fprintf('Field grid: %dx%d points\\n', grid_shape(1), grid_shape(2));

% Create compoint object for field mesh (CRITICAL for tabulation!)
fprintf('  Creating compoint for field mesh...\\n');
pt_field = compoint(p, [x_grid(:), y_grid(:), z_grid(:)], op);
fprintf('  -> Field points: %d\\n', pt_field.n);

% Check compatibility: particle + field points
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, {p, pt_field})
    fprintf('Creating new Green function table...\\n');
    
    % CRITICAL FIX: Include BOTH particle and field points in tabulation!
    fprintf('  Creating tabulation grid (particle + field points)...\\n');
"""
        
            code += f"""    tab = tabspace(layer, {{p, pt_field}}, 'nz', {nz}, 'scale', {scale});
    
    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);
    
    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');
    
    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);
    
    fprintf('  [OK] Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('[OK] Using existing compatible Green function table\\n');
end
"""
        else:
            # No field calculation: particle only (original behavior)
            code += """
% No field calculation: tabulate for particle only
if ~exist('greentab', 'var') || ~greentab.ismember(layer, enei, p)
    fprintf('Creating new Green function table...\\n');

    % Create tabulation grid for particle ONLY
    fprintf('  Creating tabulation grid (particle only)...\\n');
"""

            code += f"""    tab = tabspace(layer, p, 'nz', {nz}, 'scale', {scale});

    % Initialize Green function table
    fprintf('  Initializing compgreentablayer...\\n');
    greentab = compgreentablayer(layer, tab);

    % Precompute for actual simulation wavelengths
    fprintf('  Precomputing Green functions for %d wavelengths...\\n', length(enei));
    fprintf('  This may take several minutes...\\n');

    tic_start = tic;
    greentab = set(greentab, enei, op);
    time_elapsed = toc(tic_start);

    fprintf('  [OK] Green function table ready (%.1f seconds)\\n', time_elapsed);
else
    fprintf('[OK] Using existing compatible Green function table\\n');
end
"""

        code += """
% Add to options
op.greentab = greentab;
fprintf('[OK] Green function table added to BEM options\\n\\n');
"""

        return code
    
    def _generate_bem_solver(self):
        """Generate BEM solver initialization code."""
        use_iterative = self.config.get('use_iterative_solver', False)
        use_nonlocal = self.nonlocal_gen.is_needed()
        
        code = """
%% Initialize BEM Solver
fprintf('\\nInitializing BEM solver...\\n');
"""
        
        if use_iterative:
            code += """
% Configure iterative solver options
fprintf('  Using iterative BEM solver (for large structures)\\n');
op.iter = bemiter.options( 'output', 1 );
op.iter.tol = 1e-4;
op.iter.maxit = 200;
op.iter.solver = 'gmres';
op.iter.cleaf = 200;
op.iter.htol = 1e-6;
op.iter.kmax = [4, 100];
op.iter.fadmiss = @(rad1,rad2,dist) 2.5 * min(rad1,rad2) < dist;

fprintf('  Iterative solver parameters:\\n');
fprintf('    - Solver: %s\\n', op.iter.solver);
fprintf('    - Tolerance: %g\\n', op.iter.tol);
fprintf('    - Max iterations: %d\\n', op.iter.maxit);
"""
        
        # Add nonlocal refinement if enabled
        if use_nonlocal:
            refine_code = self.nonlocal_gen.generate_refine_function('p')
            
            code += f"""
% Nonlocal refinement for cover layer boundaries
{refine_code}

% Initialize solver with refined integration function
"""
            if use_iterative:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('[OK] Nonlocal BEM solver initialized (iterative)\\n');
"""
            else:
                code += """
bem = bemsolver( p, op, 'refun', refun );
fprintf('[OK] Nonlocal BEM solver initialized (direct)\\n');
"""
        else:
            # Standard BEM solver
            code += """
% Initialize BEM solver
try
    bem = bemsolver(p, op);
    fprintf('BEM solver initialized successfully\\n');
    fprintf('  - Boundary elements: %d\\n', size(p.pos, 1));
catch ME
    fprintf('Error initializing BEM solver: %s\\n', ME.message);
    rethrow(ME);
end
"""
        
        return code
    
    def _generate_excitation(self):
        """Generate excitation configuration."""
        excitation_type = self.config['excitation_type']
        
        if excitation_type == 'planewave':
            code = self._generate_planewave_excitation()
        elif excitation_type == 'dipole':
            code = self._generate_dipole_excitation()
        elif excitation_type == 'eels':
            code = self._generate_eels_excitation()
        else:
            raise ValueError(f"Unknown excitation type: {excitation_type}")
        
        return code
    
    def _generate_planewave_excitation(self):
        """Generate plane wave excitation code."""
        polarizations = self.config['polarizations']
        propagation_dirs = self.config['propagation_dirs']
        
        pol_str = self._python_list_to_matlab(polarizations)
        dir_str = self._python_list_to_matlab(propagation_dirs)
        
        code = f"""
%% Plane Wave Excitation
fprintf('\\nConfiguring plane wave excitation...\\n');

% Polarization vectors
pol = {pol_str};

% Propagation directions
dir = {dir_str};

fprintf('Number of polarizations: %d\\n', size(pol, 1));
fprintf('Number of propagation directions: %d\\n', size(dir, 1));
"""
        return code
    
    def _generate_dipole_excitation(self):
        """Generate dipole excitation code."""
        position = self.config.get('dipole_position', [0, 0, 15])
        moment = self.config.get('dipole_moment', [0, 0, 1])
        
        pos_str = self._python_list_to_matlab([position])
        mom_str = self._python_list_to_matlab([moment])
        
        code = f"""
%% Dipole Excitation
fprintf('\\nConfiguring dipole excitation...\\n');

% Dipole position
dip_pos = {pos_str};

% Dipole moment
dip_mom = {mom_str};

% Dummy polarization for code compatibility
pol = [0, 0, 1];  % Single "polarization" for dipole
dir = [0, 0, 1];  % Dummy propagation direction

fprintf('Dipole position: [%.2f, %.2f, %.2f] nm\\n', dip_pos(1), dip_pos(2), dip_pos(3));
"""
        return code
    
    def _generate_eels_excitation(self):
        """Generate EELS excitation code."""
        impact = self.config.get('impact_parameter', [10, 0])
        energy = self.config.get('beam_energy', 200e3)
        width = self.config.get('beam_width', 0.2)
        
        code = f"""
%% EELS Excitation
fprintf('\\nConfiguring EELS excitation...\\n');

% Impact parameter
impact = [{impact[0]}, {impact[1]}];

% Beam parameters
beam_energy = {energy};
beam_width = {width};

% Dummy polarization for code compatibility
pol = [0, 0, 1];  % Single "polarization" for EELS
dir = [0, 0, 1];  % Dummy propagation direction

fprintf('Impact parameter: [%.2f, %.2f] nm\\n', impact(1), impact(2));
fprintf('Beam energy: %.2e eV\\n', beam_energy);
"""
        return code

    def _generate_wavelength_loop(self):
        """
        Generate wavelength loop with proper parallel execution.
        
        CRITICAL FIXES (2024-12-03):
        1. Excitation MUST be initialized OUTSIDE parfor loop
        2. MNPBEM processes ALL polarizations at once (no polarization loop needed)
        3. Improved error handling and pool cleanup
        
        Based on MNPBEM official example: Demo/planewave/ret/demospecret9.m
        """
        wavelength_range = self.config['wavelength_range']
        calculate_fields = self.config.get('calculate_fields', False)
        excitation_type = self.config['excitation_type']
        use_parallel = self.config.get('use_parallel', False)
        
        code = f"""
%% Wavelength Loop
% Note: 'enei' was already defined in Green function section if substrate is used
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('              Starting BEM Calculation\\n');
fprintf('================================================================\\n');
fprintf('Wavelength range: %.1f - %.1f nm (%d points)\\n', ...
        min(enei), max(enei), n_wavelengths);
fprintf('Number of polarizations: %d\\n', n_polarizations);
"""
        
        # Add parallel setup if enabled
        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""
        
        if calculate_fields:
            code += self._generate_field_setup()
        
        # CRITICAL FIX 1: Initialize excitation BEFORE the loop!
        code += """
%% Initialize Excitation Object (CRITICAL: Must be before parallel loop!)
fprintf('\\nInitializing excitation object...\\n');
"""
    
        if excitation_type == 'planewave':
            code += """% Plane wave excitation (ALL polarizations at once)
exc = planewave(pol, dir, op);
fprintf('  [OK] Plane wave excitation initialized\\n');
fprintf('    - Polarizations: %d\\n', size(pol, 1));
fprintf('    - Propagation directions: %d\\n', size(dir, 1));
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  [OK] Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  [OK] EELS excitation initialized\\n');
"""
    
        code += """
% Start timer
calculation_start = tic;

"""
    
        # Generate loop - parfor if parallel enabled, regular for otherwise
        if use_parallel:
            code += """% ========================================
% PARALLEL EXECUTION (parfor loop)
% ========================================
if exist('parallel_enabled', 'var') && parallel_enabled
    fprintf('\\n Using PARALLEL execution (parfor loop)\\n');
    fprintf('    Progress updates may appear out of order\\n');
    fprintf('    Each worker computes independently\\n\\n');
    
    %% PARALLEL LOOP (FIXED!)
    % - Excitation object (exc) is already initialized
    % - MNPBEM processes ALL polarizations at once
    % - No need for inner polarization loop
    parfor ien = 1:n_wavelengths
        try
            % Progress indicator (less frequent for parallel)
            if mod(ien-1, max(1, floor(n_wavelengths/10))) == 0
                fprintf('  [Worker] Processing wavelength %d/%d (lambda = %.1f nm)\\n', ...
                        ien, n_wavelengths, enei(ien));
            end
            
            % FIXED: Just use pre-initialized exc object!
            % MNPBEM automatically handles ALL polarizations in one call
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (returns vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            % Error handling: print error but continue with other wavelengths
            fprintf('  ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            % Leave zeros for this wavelength
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
    
    fprintf('\\n[OK] Parallel computation completed\\n');
    
else
    % ========================================
    % SERIAL EXECUTION (for loop)
    % ========================================
    fprintf('\\n Using SERIAL execution (for loop)\\n\\n');
"""
        else:
            # Serial execution only
            code += """% ========================================
% SERIAL EXECUTION (for loop)
% ========================================
fprintf('\\nStarting wavelength loop (serial execution)...\\n\\n');
"""
    
        # FIXED: Serial loop without polarization loop
        code += """
    % Progress bar
    multiWaitbar('BEM Calculation', 0, 'Color', 'g', 'CanCancel', 'on');
    
    %% SERIAL LOOP (FIXED!)
    for ien = 1:n_wavelengths
        % Update progress bar
        multiWaitbar('BEM Calculation', ien / n_wavelengths);
        
        % Text progress indicator
        if mod(ien-1, max(1, floor(n_wavelengths/20))) == 0
            fprintf('  Progress: %d/%d (lambda = %.1f nm, %.1f%%)\\n', ...
                    ien, n_wavelengths, enei(ien), 100*ien/n_wavelengths);
        end
        
        try
            % FIXED: Use pre-initialized exc object
            % MNPBEM handles ALL polarizations automatically
            sig = bem \\ exc(p, enei(ien));
            
            % Extract cross sections (vector for all polarizations)
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);
            
        catch ME
            fprintf('  [!] ERROR at wavelength %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
"""

        if calculate_fields:
            code += self._generate_field_calculation_in_loop()

        code += """    end

    % Close waitbar
    multiWaitbar('CloseAll');
    fprintf('\\n[OK] Serial computation completed\\n');
"""
        
        if use_parallel:
            code += """end  % End of parallel/serial decision
"""
        
        # Timing
        code += """
% Calculation timing
calculation_time = toc(calculation_start);
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Calculation completed in %.2f seconds (%.2f minutes)\\n', ...
        calculation_time, calculation_time/60);
fprintf('Average time per wavelength: %.2f seconds\\n', ...
        calculation_time / n_wavelengths);
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_field_setup(self):
        """Generate field mesh setup - AFTER greentab."""
        use_substrate = self.config.get('use_substrate', False)
        
        code = """
%% Field Calculation Setup
fprintf('\\nSetting up field calculation mesh...\\n');

% Select wavelength for field calculation
"""

        field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
        
        if field_wl_idx == 'middle':
            code += """% Use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        elif field_wl_idx == 'peak':
            code += """% Find absorption peak wavelength for EACH polarization
fprintf('  Finding absorption peak for each polarization...\\n');

% Find max absorption wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_abs_pol, idx] = max(abs_cross(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak absorption %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_abs_pol, enei(idx), idx);
end

% ============================================================
% UNPOLARIZED PEAK WAVELENGTH CALCULATION
% ============================================================
% Check if polarizations are orthogonal for unpolarized calculation
unpolarized_peak_idx = -1;  % -1 means no unpolarized calculation

if n_polarizations == 2
    % Check orthogonality for plane wave (2 polarizations)
    pol1 = pol(1, :) / norm(pol(1, :));
    pol2 = pol(2, :) / norm(pol(2, :));
    dot_prod = abs(dot(pol1, pol2));

    if dot_prod < 1e-6
        fprintf('  [Unpolarized] Two orthogonal polarizations detected\\n');

        % Calculate unpolarized spectrum (average)
        unpol_abs = mean(abs_cross, 2);
        [unpol_max_abs, unpolarized_peak_idx] = max(unpol_abs);

        fprintf('  [Unpolarized] Peak absorption: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
                unpol_max_abs, enei(unpolarized_peak_idx), unpolarized_peak_idx);
    end
elseif n_polarizations == 3
    % Check orthogonality for dipole (3 directions)
    pol1 = pol(1, :) / norm(pol(1, :));
    pol2 = pol(2, :) / norm(pol(2, :));
    pol3 = pol(3, :) / norm(pol(3, :));

    dot12 = abs(dot(pol1, pol2));
    dot23 = abs(dot(pol2, pol3));
    dot13 = abs(dot(pol1, pol3));

    if dot12 < 1e-6 && dot23 < 1e-6 && dot13 < 1e-6
        fprintf('  [Unpolarized] Three orthogonal directions detected\\n');

        % Calculate unpolarized spectrum (average)
        unpol_abs = mean(abs_cross, 2);
        [unpol_max_abs, unpolarized_peak_idx] = max(unpol_abs);

        fprintf('  [Unpolarized] Peak absorption: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
                unpol_max_abs, enei(unpolarized_peak_idx), unpolarized_peak_idx);
    end
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);

% Add unpolarized peak if different from existing peaks
if unpolarized_peak_idx > 0 && ~ismember(unpolarized_peak_idx, unique_field_wavelength_indices)
    unique_field_wavelength_indices = sort([unique_field_wavelength_indices, unpolarized_peak_idx]);
    fprintf('  [Unpolarized] Added unpolarized peak wavelength to field calculation list\\n');
end

n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
for iw = 1:n_field_wavelengths
    idx = unique_field_wavelength_indices(iw);
    pols_at_this_wl = find(field_wavelength_indices == idx);

    % Check if this is the unpolarized peak
    if idx == unpolarized_peak_idx
        fprintf('     lambda = %.1f nm (index %d): UNPOLARIZED PEAK -> all polarizations\\n', ...
                enei(idx), idx);
    else
        fprintf('     lambda = %.1f nm (index %d): polarizations [%s]\\n', ...
                enei(idx), idx, num2str(pols_at_this_wl));
    end
end
"""
        elif field_wl_idx == 'peak_ext':
            code += """% Find extinction peak wavelength for EACH polarization
fprintf('  Finding extinction peak for each polarization...\\n');

% Find max extinction wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_ext_pol, idx] = max(ext(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak extinction %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_ext_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
        elif field_wl_idx == 'peak_sca':
            code += """% Find scattering peak wavelength for EACH polarization
fprintf('  Finding scattering peak for each polarization...\\n');

% Find max scattering wavelength index for each polarization
field_wavelength_indices = zeros(1, n_polarizations);
for ipol = 1:n_polarizations
    [max_sca_pol, idx] = max(sca(:, ipol));
    field_wavelength_indices(ipol) = idx;
    fprintf('    Pol %d: Peak scattering %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
            ipol, max_sca_pol, enei(idx), idx);
end

% Get unique wavelength indices (remove duplicates)
unique_field_wavelength_indices = unique(field_wavelength_indices);
n_field_wavelengths = length(unique_field_wavelength_indices);

fprintf('  -> Total %d unique wavelength(s) for field calculation\\n', n_field_wavelengths);
"""
        elif isinstance(field_wl_idx, int):
            code += f"""% Use specified wavelength index (single wavelength for all polarizations)
field_wavelength_idx = {field_wl_idx};
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        else:
            code += """% Default: use middle wavelength (single wavelength for all polarizations)
field_wavelength_idx = round(n_wavelengths / 2);
unique_field_wavelength_indices = field_wavelength_idx;
n_field_wavelengths = 1;
field_wavelength_indices = repmat(field_wavelength_idx, 1, n_polarizations);
"""
        
        code += """
fprintf('Field calculation at %d wavelength(s):\\n', n_field_wavelengths);
for iw = 1:n_field_wavelengths
    fprintf('  [%d] lambda = %.1f nm (index %d)\\n', ...
            iw, enei(unique_field_wavelength_indices(iw)), unique_field_wavelength_indices(iw));
end

"""
    
        if use_substrate:
            mindist = self.config.get('field_mindist', 0.5)
            nmax = self.config.get('field_nmax', 2000)
            
            code += f"""% Substrate mode: meshfield with pre-computed greentab
% Reshape grids back to original shape
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);  
z_grid = reshape(z_grid, grid_shape);

% Create meshfield using op with greentab
fprintf('  Creating meshfield...\\n');
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield ready with %d points\\n', emesh.pt.n);
"""
        else:
            # Standard non-substrate field setup
            field_region = self.config.get('field_region', {})
            mindist = self.config.get('field_mindist', 0.2)
            nmax = self.config.get('field_nmax', 2000)
            x_range = field_region.get('x_range', [-50, 50, 101])
            y_range = field_region.get('y_range', [0, 0, 1])
            z_range = field_region.get('z_range', [0, 0, 1])
            
            if y_range[2] == 1:  # xz-plane
                code += f"""% Create field grid: xz-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
            elif z_range[2] == 1:  # xy-plane
                code += f"""% Create field grid: xy-plane
x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
        
            code += f"""
% Create meshfield
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield created: %d points\\n', numel(x_grid));
"""

        code += """
% CRITICAL: Store grid shape for reshape operations
grid_shape = size(x_grid);

% Initialize field data storage - will store data for each (wavelength, polarization) pair
field_data = struct('wavelength', {}, 'wavelength_idx', {}, 'polarization', {}, ...
                    'polarization_idx', {}, 'e_total', {}, 'enhancement', {}, ...
                    'intensity', {}, 'x_grid', {}, 'y_grid', {}, 'z_grid', {});
field_data_idx = 0;  % Counter for field_data entries
"""
    
        return code
    
    def _generate_field_calculation_in_loop(self):
        """Generate field calculation - fixed dimension handling and excitation type."""
        excitation_type = self.config['excitation_type']
        
        code = """
        % Calculate fields at selected wavelength(s) - check if current wavelength is one of the targets
        if ismember(ien, unique_field_wavelength_indices)
            fprintf('\\n  -> Calculating fields at lambda = %.1f nm (index %d)...\\n', enei(ien), ien);
            field_calc_start = tic;

            % Find which polarizations have their peak at this wavelength
            % For unpolarized peak wavelength, calculate ALL polarizations
            if exist('unpolarized_peak_idx', 'var') && ien == unpolarized_peak_idx
                pols_at_this_wl = 1:n_polarizations;
                fprintf('    [UNPOLARIZED PEAK] Calculating ALL polarizations: [%s]\\n', num2str(pols_at_this_wl));
            else
                pols_at_this_wl = find(field_wavelength_indices == ien);
                fprintf('    Polarizations with peak at this wavelength: [%s]\\n', num2str(pols_at_this_wl));
            end

            fprintf('  Computing induced fields...\\n');
            e_induced_obj = emesh(sig);

            % Extract numeric array from field object
            if isobject(e_induced_obj) || isstruct(e_induced_obj)
                if isfield(e_induced_obj, 'e') || isprop(e_induced_obj, 'e')
                    e_induced_all = e_induced_obj.e;
                elseif isfield(e_induced_obj, 'val') || isprop(e_induced_obj, 'val')
                    e_induced_all = e_induced_obj.val;
                else
                    e_induced_all = double(e_induced_obj);
                end
            else
                e_induced_all = e_induced_obj;
            end

            grid_shape = size(x_grid);

            % Process polarizations for this wavelength
            for ipol_loop = 1:length(pols_at_this_wl)
                ipol = pols_at_this_wl(ipol_loop);
                fprintf('    Processing polarization %d...\\n', ipol);

"""
        
        if excitation_type == 'planewave':
            code += """                % Create single-polarization plane wave excitation
                exc_single = planewave(pol(ipol, :), dir(ipol, :), op);
"""
        elif excitation_type == 'dipole':
            code += """                % Dipole excitation
                pt_single = compoint(p, dip_pos, op);
                exc_single = dipole(pt_single, dip_mom, op);
"""
        elif excitation_type == 'eels':
            code += """                % EELS excitation
                exc_single = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""
        
        code += """
                % Extract induced field for this polarization
                if n_polarizations > 1
                    e_induced = e_induced_all(:, :, ipol);
                else
                    e_induced = e_induced_all;
                end
                fprintf('      e_induced size: [%s]\\n', num2str(size(e_induced)));

                % Calculate incoming field for this polarization
                e_incoming_obj = exc_single.field(emesh.pt, enei(ien));

                % Extract numeric array from field object
                if isobject(e_incoming_obj) || isstruct(e_incoming_obj)
                    if isfield(e_incoming_obj, 'e') || isprop(e_incoming_obj, 'e')
                        e_incoming = e_incoming_obj.e;
                    elseif isfield(e_incoming_obj, 'val') || isprop(e_incoming_obj, 'val')
                        e_incoming = e_incoming_obj.val;
                    else
                        e_incoming = double(e_incoming_obj);
                    end
                else
                    e_incoming = e_incoming_obj;
                end
                fprintf('      e_incoming size: [%s]\\n', num2str(size(e_incoming)));

                % Ensure 2D arrays for addition
                if ndims(e_induced) == 3
                    e_induced = squeeze(e_induced);
                end
                if ndims(e_incoming) == 3
                    e_incoming = squeeze(e_incoming);
                end

                % Handle size mismatch
                sz_induced = size(e_induced);
                sz_incoming = size(e_incoming);

                if ~isequal(sz_induced, sz_incoming)
                    fprintf('    [!] Size mismatch: e_induced [%s], e_incoming [%s]\\n', ...
                            num2str(sz_induced), num2str(sz_incoming));

                    if isequal(sz_induced, fliplr(sz_incoming))
                        e_incoming = e_incoming.';
                    elseif numel(e_induced) == numel(e_incoming)
                        e_incoming = reshape(e_incoming, size(e_induced));
                    elseif sz_induced(1) == sz_incoming(1)
                        if sz_incoming(2) > sz_induced(2)
                            e_incoming = e_incoming(:, 1:sz_induced(2));
                        elseif sz_induced(2) > sz_incoming(2)
                            e_induced = e_induced(:, 1:sz_incoming(2));
                        end
                    end
                    fprintf('    -> Fixed sizes: e_induced [%s], e_incoming [%s]\\n', ...
                            num2str(size(e_induced)), num2str(size(e_incoming)));
                end

                % Total field
                e_total = e_induced + e_incoming;
                
                e_intensity = dot(e_total, e_total, 2);
                e0_intensity = dot(e_incoming, e_incoming, 2);
                enhancement = sqrt(e_intensity ./ e0_intensity);
                
                % Handle meshfield point filtering (mindist option)
                % meshfield removes points too close to particle surface
                n_grid_points = numel(x_grid);
                n_field_points = length(enhancement);
                
                if n_field_points < n_grid_points
                    % Points were filtered - create full grid with NaN
                    fprintf('    -> Grid filtering: %d/%d points used (mindist=%.2f nm)\\n', ...
                            n_field_points, n_grid_points, field_mindist);
                    
                    % Create NaN-filled arrays
                    enhancement_full = nan(n_grid_points, 1);
                    e_intensity_full = nan(n_grid_points, 1);
                    
                    % Fill valid points using meshfield indices
                    if exist('emesh_ind', 'var') && ~isempty(emesh_ind)
                        enhancement_full(emesh_ind) = enhancement;
                        e_intensity_full(emesh_ind) = e_intensity;
                    else
                        % Fallback: match by coordinates (slower but works)
                        fprintf('    [!] Warning: emesh_ind not found, using coordinate matching\\n');
                        x_flat = x_grid(:);
                        y_flat = y_grid(:);
                        z_flat = z_grid(:);
                        for ii = 1:n_field_points
                            % Find matching coordinates
                            dx = abs(x_flat - emesh.pt.pos(ii,1));
                            dy = abs(y_flat - emesh.pt.pos(ii,2));
                            dz = abs(z_flat - emesh.pt.pos(ii,3));
                            [~, idx] = min(dx + dy + dz);
                            enhancement_full(idx) = enhancement(ii);
                            e_intensity_full(idx) = e_intensity(ii);
                        end
                    end
                    
                    enhancement = enhancement_full;
                    e_intensity = e_intensity_full;
                end
                
                % Now safely reshape
                enhancement = reshape(enhancement, grid_shape);
                e_intensity = reshape(e_intensity, grid_shape);

                % Store with wavelength and polarization indices
                field_data_idx = field_data_idx + 1;
                field_data(field_data_idx).wavelength = enei(ien);
                field_data(field_data_idx).wavelength_idx = ien;
                field_data(field_data_idx).polarization = pol(ipol, :);
                field_data(field_data_idx).polarization_idx = ipol;
                field_data(field_data_idx).e_total = e_total;
                field_data(field_data_idx).enhancement = enhancement;
                field_data(field_data_idx).intensity = e_intensity;
                field_data(field_data_idx).x_grid = x_grid;
                field_data(field_data_idx).y_grid = y_grid;
                field_data(field_data_idx).z_grid = z_grid;

                fprintf('      -> Stored as field_data(%d): lambda=%.1f nm, pol=%d\\n', ...
                        field_data_idx, enei(ien), ipol);
            end

            field_calc_time = toc(field_calc_start);
            fprintf('\\n[OK] Field calculation at lambda=%.1f nm completed in %.2f seconds\\n', ...
                    enei(ien), field_calc_time);
            fprintf('================================================================\\n');

            % Update total calculation time
            calculation_time = calculation_time + field_calc_time;
        end
"""

        return code

    def _generate_save_results(self):
        """Generate code to save simulation results."""
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = """
%% Save Results
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Saving results...\\n');

results = struct();
results.wavelength = enei;
results.scattering = sca;
results.extinction = ext;
results.absorption = abs_cross;
results.polarizations = pol;
results.propagation_dirs = dir;
results.calculation_time = calculation_time;
"""
        
        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    results.fields = field_data;
    fprintf('Field data included in results\\n');
end
"""
        
        code += """
save('simulation_results.mat', 'results');
fprintf('[OK] Results saved to: simulation_results.mat\\n');

% Save cross sections to text file
fid = fopen('simulation_results.txt', 'w');
fprintf(fid, 'Wavelength(nm)\\t');
for ipol = 1:n_polarizations
    fprintf(fid, 'Sca_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    fprintf(fid, 'Ext_pol%d\\t', ipol);
end
for ipol = 1:n_polarizations
    if ipol < n_polarizations
        fprintf(fid, 'Abs_pol%d\\t', ipol);
    else
        fprintf(fid, 'Abs_pol%d', ipol);
    end
end
fprintf(fid, '\\n');

for i = 1:length(enei)
    fprintf(fid, '%.2f\\t', enei(i));
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', sca(i, ipol));
    end
    for ipol = 1:n_polarizations
        fprintf(fid, '%.6e\\t', ext(i, ipol));
    end
    for ipol = 1:n_polarizations
        if ipol < n_polarizations
            fprintf(fid, '%.6e\\t', abs_cross(i, ipol));
        else
            fprintf(fid, '%.6e', abs_cross(i, ipol));
        end
    end
    fprintf(fid, '\\n');
end
fclose(fid);
fprintf('[OK] Cross sections saved to: simulation_results.txt\\n');
"""

        if calculate_fields:
            code += """
if exist('field_data', 'var') && ~isempty(field_data)
    save('field_data.mat', 'field_data', '-v7.3');
    fprintf('[OK] Field data saved to: field_data.mat\\n');
end
"""
        
        code += """
fprintf('================================================================\\n');
"""
        
        return code
    
    def _generate_footer(self):
        """
        Generate safe cleanup and exit code.
        
        CRITICAL FIXES:
        1. File verification BEFORE clearing variables (prevents index error)
        2. Safe try-catch for dir() with numel() check
        3. Waitbar cleanup first to prevent ^H characters
        4. Improved parallel cleanup with longer timeout
        """
        use_parallel = self.config.get('use_parallel', False)
        
        code = """
%% Cleanup and Exit
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('Cleaning up...\\n');

"""

        # Add parallel cleanup if parallel was enabled
        if use_parallel:
            code += self._generate_parallel_cleanup()
        
        code += """
% Close all waitbars FIRST (to prevent ^H characters in output)
try
    multiWaitbar('CloseAll');
    fprintf('  [OK] Closed all waitbars\\n');
catch
    % multiWaitbar not used or already closed
end

% Close all figures
close all;
fprintf('  [OK] Closed all figures\\n');

% CRITICAL: Close all file handles AND force sync to disk
fclose('all');
fprintf('  [OK] Closed all file handles\\n');

% ========================================
% IMPORTANT: Verify files BEFORE clearing variables!
% ========================================
if exist('field_data.mat', 'file')
    fprintf('  -> Verifying field_data.mat...\\n');
    try
        file_info = dir('field_data.mat');
        % SAFE: Check both isempty and numel
        if ~isempty(file_info) && numel(file_info) >= 1
            fprintf('    File size: %.2f MB\\n', file_info(1).bytes / 1024 / 1024);
        else
            fprintf('    Warning: File exists but dir() returned empty\\n');
        end
    catch ME
        fprintf('    Warning: Could not verify file: %s\\n', ME.message);
    end
end

if exist('simulation_results.mat', 'file')
    fprintf('  -> Verifying simulation_results.mat...\\n');
    try
        file_info = dir('simulation_results.mat');
        if ~isempty(file_info) && numel(file_info) >= 1
            fprintf('    File size: %.2f MB\\n', file_info(1).bytes / 1024 / 1024);
        end
    catch ME
        fprintf('    Warning: Could not verify file: %s\\n', ME.message);
    end
end

% Clear large variables to free memory (AFTER file verification)
clear bem sig field_data meshfield e_induced e_incoming e_total enhancement;
fprintf('  [OK] Cleared temporary variables\\n');

fprintf('================================================================\\n');
fprintf('\\n');
fprintf('=== MNPBEM Simulation Completed Successfully ===\\n');
fprintf('\\n');

%% Safe Exit Sequence
fprintf('Preparing to exit MATLAB...\\n');

% IMPROVED: Longer pause for I/O completion (5 seconds instead of 3)
fprintf('  Waiting for all I/O operations to complete...\\n');
pause(5);

% Turn off diary if it was on
try
    diary off;
catch
    % Ignore if diary wasn't on
end

% Safe exit
fprintf('Exiting MATLAB now.\\n');
fprintf('\\n');

% FIXED: Use 'exit' instead of invalid 'quit force'
exit;
"""
        return code
    
    def _python_list_to_matlab(self, python_list):
        """Convert Python list to MATLAB array string."""
        if not python_list:
            return '[]'
        
        if isinstance(python_list[0], (list, tuple)):
            rows = []
            for row in python_list:
                row_str = ', '.join([str(x) for x in row])
                rows.append(row_str)
            return '[' + '; '.join(rows) + ']'
        else:
            return '[' + ', '.join([str(x) for x in python_list]) + ']'

    def _extract_closed_args(self, material_code):
        """Extract closed arguments from material code."""
        # Find: closed = [1, 2];
        if 'closed = [' in material_code:
            start = material_code.find('closed = [') + len('closed = [')
            end = material_code.find(']', start)
            self._closed_args = material_code[start:end].strip()
        else:
            # Single value: closed = 1;
            if 'closed = ' in material_code:
                start = material_code.find('closed = ') + len('closed = ')
                end = material_code.find(';', start)
                self._closed_args = material_code[start:end].strip()
            else:
                self._closed_args = "1"

    def _generate_wavelength_loop_with_chunking(self):
        """
        Wavelength loop with memory-efficient chunking AND field calculation support.
        
        ✅ CRITICAL FIX (2024-12-05 - FINAL):
        1. Field calculation uses SEPARATE BEM solutions for each polarization
        2. meshfield uses standard x_grid, y_grid, z_grid (NOT pt_field directly!)
        3. emesh_ind variable stores accurate coordinate mapping (separate from meshfield)
        
        This fixes:
        - Polarization 2 being all zeros
        - Field concentration in bottom-left corner
        - Coordinate matching errors
        - meshfield creation error with pt_field
        
        Strategy: 
        1. Calculate ALL cross sections first (no field in loop)
        2. Find peak AFTER all chunks complete
        3. Calculate field separately for peak wavelength - EACH polarization independently
        4. Use standard meshfield creation with accurate index mapping
        """
        
        wavelength_range = self.config['wavelength_range']
        chunk_size = self.config.get('wavelength_chunk_size', 20)
        use_parallel = self.config.get('use_parallel', False)
        excitation_type = self.config['excitation_type']
        calculate_fields = self.config.get('calculate_fields', False)
        
        code = f"""
%% Wavelength Loop with Chunking (Memory-Efficient!)
if ~exist('enei', 'var')
    enei = linspace({wavelength_range[0]}, {wavelength_range[1]}, {wavelength_range[2]});
end

n_wavelengths = length(enei);
n_polarizations = size(pol, 1);

% Chunking setup
chunk_size = {chunk_size};
n_chunks = ceil(n_wavelengths / chunk_size);

fprintf('\\n');
fprintf('================================================================\\n');
fprintf('     Starting BEM Calculation with Wavelength Chunking         \\n');
fprintf('================================================================\\n');
fprintf('Total wavelengths: %d\\n', n_wavelengths);
fprintf('Chunk size: %d wavelengths\\n', chunk_size);
fprintf('Number of chunks: %d\\n', n_chunks);
fprintf('----------------------------------------------------------------\\n');

% Initialize result arrays
sca = zeros(n_wavelengths, n_polarizations);
ext = zeros(n_wavelengths, n_polarizations);
abs_cross = zeros(n_wavelengths, n_polarizations);
"""

        if use_parallel:
            code += self._generate_parallel_setup()
        
        code += """
%% Initialize Excitation (once, outside all loops!)
fprintf('\\nInitializing excitation object...\\n');
"""

        if excitation_type == 'planewave':
            code += """exc = planewave(pol, dir, op);
fprintf('  [OK] Plane wave excitation initialized\\n');
"""
        elif excitation_type == 'dipole':
            code += """pt = compoint(p, dip_pos, op);
exc = dipole(pt, dip_mom, op);
fprintf('  [OK] Dipole excitation initialized\\n');
"""
        elif excitation_type == 'eels':
            code += """exc = eelsret(p, impact, beam_energy, 'width', beam_width, op);
fprintf('  [OK] EELS excitation initialized\\n');
"""

        code += """
% Start overall timer
total_start = tic;

%% ========================================
%% CHUNK LOOP: Calculate cross sections ONLY (NO field calculation)
%% ========================================
for ichunk = 1:n_chunks
    % Calculate wavelength indices for this chunk
    idx_start = (ichunk-1) * chunk_size + 1;
    idx_end = min(ichunk * chunk_size, n_wavelengths);
    chunk_indices = idx_start:idx_end;
    n_chunk = length(chunk_indices);
    
    fprintf('\\n');
    fprintf('================================================================\\n');
    fprintf('  Processing Chunk %d/%d: wavelengths %d-%d (%d points)\\n', ...
            ichunk, n_chunks, idx_start, idx_end, n_chunk);
    fprintf('  lambda range: %.1f - %.1f nm\\n', ...
            enei(idx_start), enei(idx_end));
    fprintf('================================================================\\n');
    
    chunk_start = tic;
    
    % CRITICAL: Clear BEM solver between chunks!
    if ichunk > 1
        fprintf('  -> Clearing BEM memory from previous chunk...\\n');
        clear bem;
        bem = bemsolver(p, op);  % Re-initialize BEM solver
        fprintf('  [OK] Memory cleared and BEM re-initialized\\n');
    end
    
"""

        if use_parallel:
            code += """    % Parallel/Serial processing within chunk
    if exist('parallel_enabled', 'var') && parallel_enabled
        fprintf('  Using parallel execution for this chunk\\n\\n');

        % Pre-allocate chunk-local arrays for parfor slicing
        sca_chunk = zeros(n_chunk, n_polarizations);
        ext_chunk = zeros(n_chunk, n_polarizations);
        abs_chunk = zeros(n_chunk, n_polarizations);

        parfor i_local = 1:n_chunk
            ien = chunk_indices(i_local);

            try
                % Progress
                if mod(i_local-1, max(1, floor(n_chunk/5))) == 0
                    fprintf('    [Worker] lambda %d/%d (%.1f nm)\\n', ...
                            i_local, n_chunk, enei(ien));
                end

                % BEM calculation (cross sections only)
                sig = bem \\ exc(p, enei(ien));

                % Store results using loop variable (parfor-compatible)
                sca_chunk(i_local, :) = exc.sca(sig);
                ext_chunk(i_local, :) = exc.ext(sig);
                abs_chunk(i_local, :) = ext_chunk(i_local, :) - sca_chunk(i_local, :);

            catch ME
                fprintf('    ERROR at lambda %d (%.1f nm): %s\\n', ...
                        ien, enei(ien), ME.message);
                sca_chunk(i_local, :) = zeros(1, n_polarizations);
                ext_chunk(i_local, :) = zeros(1, n_polarizations);
                abs_chunk(i_local, :) = zeros(1, n_polarizations);
            end
        end

        % Copy chunk results to main arrays
        sca(chunk_indices, :) = sca_chunk;
        ext(chunk_indices, :) = ext_chunk;
        abs_cross(chunk_indices, :) = abs_chunk;

    else
        fprintf('  Using serial execution for this chunk\\n\\n');

        for i_local = 1:n_chunk
            ien = chunk_indices(i_local);

            % Progress
            if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
                fprintf('    Progress: %d/%d (lambda = %.1f nm)\\n', ...
                        i_local, n_chunk, enei(ien));
            end

            try
                % BEM calculation (cross sections only)
                sig = bem \\ exc(p, enei(ien));

                % Store results
                sca(ien, :) = exc.sca(sig);
                ext(ien, :) = exc.ext(sig);
                abs_cross(ien, :) = ext(ien, :) - sca(ien, :);

            catch ME
                fprintf('    ERROR at lambda %d (%.1f nm): %s\\n', ...
                        ien, enei(ien), ME.message);
                sca(ien, :) = zeros(1, n_polarizations);
                ext(ien, :) = zeros(1, n_polarizations);
                abs_cross(ien, :) = zeros(1, n_polarizations);
            end
        end
    end
"""
        else:
            # Serial only
            code += """    % Serial processing within chunk
    fprintf('  Using serial execution for this chunk\\n\\n');

    for i_local = 1:n_chunk
        ien = chunk_indices(i_local);

        % Progress
        if mod(i_local-1, max(1, floor(n_chunk/10))) == 0
            fprintf('    Progress: %d/%d (lambda = %.1f nm)\\n', ...
                    i_local, n_chunk, enei(ien));
        end

        try
            % BEM calculation (cross sections only)
            sig = bem \\ exc(p, enei(ien));

            % Store results
            sca(ien, :) = exc.sca(sig);
            ext(ien, :) = exc.ext(sig);
            abs_cross(ien, :) = ext(ien, :) - sca(ien, :);

        catch ME
            fprintf('    ERROR at lambda %d (%.1f nm): %s\\n', ...
                    ien, enei(ien), ME.message);
            sca(ien, :) = zeros(1, n_polarizations);
            ext(ien, :) = zeros(1, n_polarizations);
            abs_cross(ien, :) = zeros(1, n_polarizations);
        end
    end
"""
        
        # Chunk timing
        code += """    
    chunk_time = toc(chunk_start);
    fprintf('\\n  [OK] Chunk %d completed in %.1f seconds (%.1f min)\\n', ...
            ichunk, chunk_time, chunk_time/60);
    fprintf('  Average: %.2f sec/wavelength\\n', chunk_time/n_chunk);
    
    % Force garbage collection between chunks
    pause(1);
end

% Total timing for cross sections
total_time = toc(total_start);
calculation_time = total_time;
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('ALL CHUNKS COMPLETED\\n');
fprintf('Total time: %.1f seconds (%.1f minutes)\\n', total_time, total_time/60);
fprintf('Average: %.2f seconds/wavelength\\n', total_time/n_wavelengths);
fprintf('================================================================\\n');
"""

        # ================================================================
        # ✅✅✅ CORRECTED FIELD CALCULATION ✅✅✅
        # ================================================================
        if calculate_fields:
            code += """
%% ========================================
%% FIELD CALCULATION (After all chunks complete)
%% ========================================
fprintf('\\n');
fprintf('================================================================\\n');
fprintf('           Field Calculation at Peak Wavelength                \\n');
fprintf('================================================================\\n');
"""
            
            # Determine peak wavelength
            field_wl_idx = self.config.get('field_wavelength_idx', 'middle')
            
            if field_wl_idx == 'middle':
                code += """
% Use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
fprintf('Using middle wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak':
                code += """
% Find absorption peak wavelength
fprintf('Finding absorption peak...\\n');
abs_avg = mean(abs_cross, 2);
[max_abs, field_wavelength_idx] = max(abs_avg);
fprintf('  [OK] Peak absorption: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
        max_abs, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak_ext':
                code += """
% Find extinction peak wavelength
fprintf('Finding extinction peak...\\n');
ext_avg = mean(ext, 2);
[max_ext, field_wavelength_idx] = max(ext_avg);
fprintf('  [OK] Peak extinction: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
        max_ext, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif field_wl_idx == 'peak_sca':
                code += """
% Find scattering peak wavelength
fprintf('Finding scattering peak...\\n');
sca_avg = mean(sca, 2);
[max_sca, field_wavelength_idx] = max(sca_avg);
fprintf('  [OK] Peak scattering: %.2e nm^2 at lambda = %.1f nm (index %d)\\n', ...
        max_sca, enei(field_wavelength_idx), field_wavelength_idx);
"""
            elif isinstance(field_wl_idx, int):
                code += f"""
% Use specified wavelength index
field_wavelength_idx = {field_wl_idx};
fprintf('Using specified wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            else:
                code += """
% Default: use middle wavelength
field_wavelength_idx = round(n_wavelengths / 2);
fprintf('Using middle wavelength: lambda = %.1f nm (index %d)\\n', ...
        enei(field_wavelength_idx), field_wavelength_idx);
"""
            
            # ================================================================
            # ✅ CORRECTED: Standard meshfield creation (NOT using pt_field)
            # ================================================================
            use_substrate = self.config.get('use_substrate', False)
            
            if use_substrate:
                mindist = self.config.get('field_mindist', 0.5)
                nmax = self.config.get('field_nmax', 2000)
                code += f"""
% Create meshfield (substrate mode with greentab)
fprintf('\\nCreating meshfield for substrate...\\n');
x_grid = reshape(x_grid, grid_shape);
y_grid = reshape(y_grid, grid_shape);
z_grid = reshape(z_grid, grid_shape);

% Use standard meshfield creation
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield ready: %d points\\n', emesh.pt.n);

% CRITICAL FIX: Create accurate index mapping
if ~exist('emesh_ind', 'var') || isempty(emesh_ind)
    fprintf('  Creating index mapping for grid reconstruction...\\n');
    
    % Flatten original grids
    x_flat = x_grid(:);
    y_flat = y_grid(:);
    z_flat = z_grid(:);
    
    % Find indices for each calculated point
    emesh_ind = zeros(emesh.pt.n, 1);
    n_matched = 0;
    
    for ii = 1:emesh.pt.n
        % Calculate distance to all grid points
        dist = sqrt((x_flat - emesh.pt.pos(ii,1)).^2 + ...
                   (y_flat - emesh.pt.pos(ii,2)).^2 + ...
                   (z_flat - emesh.pt.pos(ii,3)).^2);
        
        % Find closest match
        [min_dist, idx] = min(dist);
        
        % Store index
        emesh_ind(ii) = idx;
        
        % Verify match quality
        if min_dist < 0.01  % Tolerance: 0.01 nm
            n_matched = n_matched + 1;
        else
            % Warning for poor matches
            if min_dist > 0.1
                fprintf('    Warning: Point %d has poor match (dist=%.4f nm)\\n', ii, min_dist);
            end
        end
    end
    
    % emesh_ind variable now holds the mapping indices
    % (Cannot add custom properties to meshfield class)

    fprintf('  [OK] Index mapping created: %d/%d points matched exactly\\n', ...
            n_matched, emesh.pt.n);
end
"""
            else:
                field_region = self.config.get('field_region', {})
                mindist = self.config.get('field_mindist', 0.2)
                nmax = self.config.get('field_nmax', 2000)
                x_range = field_region.get('x_range', [-50, 50, 101])
                y_range = field_region.get('y_range', [0, 0, 1])
                z_range = field_region.get('z_range', [0, 0, 1])
                
                code += """
% Create meshfield
fprintf('\\nCreating field grid...\\n');
"""
                
                if y_range[2] == 1:  # xz-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
z_field = linspace({z_range[0]}, {z_range[1]}, {z_range[2]});
[x_grid, z_grid] = meshgrid(x_field, z_field);
y_grid = {y_range[0]} * ones(size(x_grid));
"""
                elif z_range[2] == 1:  # xy-plane
                    code += f"""x_field = linspace({x_range[0]}, {x_range[1]}, {x_range[2]});
y_field = linspace({y_range[0]}, {y_range[1]}, {y_range[2]});
[x_grid, y_grid] = meshgrid(x_field, y_field);
z_grid = {z_range[0]} * ones(size(x_grid));
"""
                
                code += f"""
field_mindist = {mindist};  % Store mindist for later use
emesh = meshfield(p, x_grid, y_grid, z_grid, op, ...
                  'mindist', field_mindist, 'nmax', {nmax});
fprintf('  [OK] Meshfield created: %d points\\n', numel(x_grid));

% CRITICAL FIX: Create accurate index mapping for grid reconstruction
% This maps meshfield output points back to original grid positions
if ~exist('emesh_ind', 'var') || isempty(emesh_ind)
    fprintf('  Creating index mapping for grid reconstruction...\\n');

    % Flatten original grids
    x_flat = x_grid(:);
    y_flat = y_grid(:);
    z_flat = z_grid(:);

    % Find indices for each calculated point
    emesh_ind = zeros(emesh.pt.n, 1);
    n_matched = 0;

    for ii = 1:emesh.pt.n
        % Calculate distance to all grid points
        dist = sqrt((x_flat - emesh.pt.pos(ii,1)).^2 + ...
                   (y_flat - emesh.pt.pos(ii,2)).^2 + ...
                   (z_flat - emesh.pt.pos(ii,3)).^2);

        % Find closest match
        [min_dist, idx] = min(dist);

        % Store index
        emesh_ind(ii) = idx;

        % Verify match quality
        if min_dist < 0.01  % Tolerance: 0.01 nm
            n_matched = n_matched + 1;
        else
            % Warning for poor matches
            if min_dist > 0.1
                fprintf('    Warning: Point %d has poor match (dist=%.4f nm)\\n', ii, min_dist);
            end
        end
    end

    fprintf('  [OK] Index mapping created: %d/%d points matched exactly\\n', ...
            n_matched, emesh.pt.n);
end
"""

            # ================================================================
            # Each polarization calculated separately
            # ================================================================
            code += """
% Initialize field data storage
field_data = struct();

% Calculate fields at peak wavelength
fprintf('\\nCalculating fields at lambda = %.1f nm...\\n', enei(field_wavelength_idx));
field_calc_start = tic;

% Store grid info for later use
n_grid_points = numel(x_grid);

% ================================================================
% CRITICAL FIX: Calculate BEM solution SEPARATELY for each polarization
% This is the correct approach used in all MNPBEM demo files
% ================================================================
for ipol = 1:n_polarizations
    fprintf('  Processing polarization %d/%d...\\n', ipol, n_polarizations);

"""
            
            # Create single-polarization excitation
            if excitation_type == 'planewave':
                code += """    % STEP 1: Create single-polarization plane wave excitation
    exc_single = planewave(pol(ipol, :), dir(ipol, :), op);
"""
            elif excitation_type == 'dipole':
                code += """    % STEP 1: Create single-polarization dipole excitation
    pt_single = compoint(p, dip_pos, op);
    exc_single = dipole(pt_single, dip_mom, op);
"""
            elif excitation_type == 'eels':
                code += """    % STEP 1: Create EELS excitation
    exc_single = eelsret(p, impact, beam_energy, 'width', beam_width, op);
"""

            # Calculate each component separately
            code += """
    % STEP 2: Compute BEM solution for THIS polarization ONLY
    fprintf('    Computing BEM solution...\\n');
    sig_single = bem \\ exc_single(p, enei(field_wavelength_idx));

    % STEP 3: Compute induced field for THIS polarization
    fprintf('    Computing induced field...\\n');
    e_induced_obj = emesh(sig_single);

    % Extract numeric array from field object
    if isobject(e_induced_obj) || isstruct(e_induced_obj)
        if isfield(e_induced_obj, 'e') || isprop(e_induced_obj, 'e')
            e_induced = e_induced_obj.e;
        elseif isfield(e_induced_obj, 'val') || isprop(e_induced_obj, 'val')
            e_induced = e_induced_obj.val;
        else
            e_induced = double(e_induced_obj);
        end
    else
        e_induced = e_induced_obj;
    end
    fprintf('      e_induced size: [%s]\\n', num2str(size(e_induced)));

    % STEP 4: Compute incoming field for THIS polarization
    fprintf('    Computing incoming field...\\n');
    e_incoming_obj = exc_single.field(emesh.pt, enei(field_wavelength_idx));

    % Extract numeric array from field object
    if isobject(e_incoming_obj) || isstruct(e_incoming_obj)
        if isfield(e_incoming_obj, 'e') || isprop(e_incoming_obj, 'e')
            e_incoming = e_incoming_obj.e;
        elseif isfield(e_incoming_obj, 'val') || isprop(e_incoming_obj, 'val')
            e_incoming = e_incoming_obj.val;
        else
            e_incoming = double(e_incoming_obj);
        end
    else
        e_incoming = e_incoming_obj;
    end
    fprintf('      e_incoming size: [%s]\\n', num2str(size(e_incoming)));

    % STEP 5: Handle dimension mismatch - EXPAND e_incoming to grid form
    % emesh(sig) returns grid shape [nx, ny, 3] with NaN for invalid points (for visualization)
    % exc.field(emesh.pt) returns [n_meshfield_pts, 3] (only valid points)
    % We want to KEEP the grid form and expand e_incoming to match
    sz_induced = size(e_induced);
    sz_incoming = size(e_incoming);
    n_emesh_pts = emesh.pt.n;
    grid_shape = size(x_grid);

    fprintf('      meshfield has %d points (grid has %d total)\\n', n_emesh_pts, n_grid_points);

    % KEEP GRID FORM: If e_induced is grid-shaped, expand e_incoming to grid
    if ndims(e_induced) == 3 && sz_induced(3) == 3 && numel(sz_incoming) == 2 && sz_incoming(1) == n_emesh_pts
        fprintf('      -> e_induced is grid [%dx%dx3], e_incoming is points [%dx3]\\n', ...
                sz_induced(1), sz_induced(2), sz_incoming(1));
        fprintf('      -> Expanding e_incoming to grid form (NaN for invalid points)...\\n');

        % Create full grid array filled with NaN
        e_incoming_grid = nan(n_grid_points, 3);

        % Place valid meshfield points into grid using emesh_ind
        if exist('emesh_ind', 'var') && ~isempty(emesh_ind) && length(emesh_ind) == n_emesh_pts
            e_incoming_grid(emesh_ind, :) = e_incoming;
            fprintf('      -> Placed %d valid points into grid using emesh_ind\\n', n_emesh_pts);
        else
            fprintf('      [!] emesh_ind not available, cannot expand to grid!\\n');
            error('emesh_ind required for grid expansion');
        end

        % Reshape e_incoming to match e_induced grid shape [nx, ny, 3]
        e_incoming = reshape(e_incoming_grid, [grid_shape, 3]);
        fprintf('      -> e_incoming now: [%s]\\n', num2str(size(e_incoming)));
        fprintf('      -> e_induced kept: [%s]\\n', num2str(size(e_induced)));
    else
        % Both are already in compatible form, just squeeze if needed
        if ndims(e_induced) == 3
            e_induced = squeeze(e_induced);
            fprintf('      e_induced squeezed to: [%s]\\n', num2str(size(e_induced)));
        end
        if ndims(e_incoming) == 3
            e_incoming = squeeze(e_incoming);
            fprintf('      e_incoming squeezed to: [%s]\\n', num2str(size(e_incoming)));
        end
    end

    % Verify sizes match now
    if ~isequal(size(e_induced), size(e_incoming))
        fprintf('    [!] Size mismatch after expansion!\\n');
        fprintf('        e_induced: [%s], e_incoming: [%s]\\n', ...
                num2str(size(e_induced)), num2str(size(e_incoming)));
        error('Field array size mismatch - check emesh_ind mapping');
    end

    % STEP 6: Calculate total field and enhancement (in grid form)
    % NaN + anything = NaN, so invalid points stay NaN (good for visualization)
    e_total = e_induced + e_incoming;

    % For 3D grid arrays, compute intensity along 3rd dimension
    if ndims(e_total) == 3
        e_intensity = sum(e_total .* e_total, 3);
        e0_intensity = sum(e_incoming .* e_incoming, 3);
    else
        e_intensity = dot(e_total, e_total, 2);
        e0_intensity = dot(e_incoming, e_incoming, 2);
    end
    enhancement = sqrt(e_intensity ./ e0_intensity);

    % Enhancement is already in grid shape [nx, ny] - no need to reshape
    fprintf('      enhancement shape: [%s]\\n', num2str(size(enhancement)));
    fprintf('      e_intensity shape: [%s]\\n', num2str(size(e_intensity)));

    % STEP 9: Store results
    field_data(ipol).polarization = pol(ipol, :);
    field_data(ipol).wavelength = enei(field_wavelength_idx);
    field_data(ipol).e_total = e_total;
    field_data(ipol).enhancement = enhancement;
    field_data(ipol).intensity = e_intensity;
    field_data(ipol).x_grid = x_grid;
    field_data(ipol).y_grid = y_grid;
    field_data(ipol).z_grid = z_grid;
end

field_calc_time = toc(field_calc_start);
fprintf('\\n[OK] Field calculation completed in %.2f seconds\\n', field_calc_time);
fprintf('================================================================\\n');

% Update total calculation time
calculation_time = calculation_time + field_calc_time;
"""
        
        return code
